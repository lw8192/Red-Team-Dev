# Binary Exploitation    
## Learn     
[Flagbot CTF Lessons](https://flagbot.ch/material/)     
[Live Overflow Paylist](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)   
[Binary Exploitation Notes](https://ir0nstone.gitbook.io/notes/)       
[Binary Exploitation Roadmap](https://www.hoppersroppers.org/roadmap/training/pwning.html)       
[Windows Internals CTF](https://samsclass.info/126/WI2021_CCC.htm)    
[pwn.college](https://pwn.college/)    
 
## Tools     
[GDB](https://www.sourceware.org/gdb/)    
[GEF](https://github.com/hugsy/gef)   
[Cutter](https://cutter.re/)    
[PEDA](https://github.com/longld/peda)    
[Pwntools](https://github.com/Gallopsled/pwntools), [Pwntools Tutorials](https://github.com/Gallopsled/pwntools-tutorial)        
Ghidra    
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly2)    
32 vs 64 bit: the main difference is how you pass arguments to functions. In 32 bit systems, arguments are pushed to the stack before a function is called. In 64 bit the first 6 arguments are pushed to RDI, RSI, RDX, RCX, R8 and R9. Some OSs might have different calling coventions.         


        file binary     #note architechure of the binary, are debugging symbols stripped?     
        strings binary   #note strings, function calls   

If a binary is not stripped of debugging symbols:    

        readelf -s program     
Disassemble and find function locations:       

        objdump -d program     
Open the binary in Ghidra, decompile it and look at the source code.   
ltrace: record library calls made in an executable to see what context they are used in.      

        ltrace ./program      

## Format String Vulnerabilities     
Format parameter: Escape sequences - begins with a %, uses a single char shorthand. Common format parameters: %d, %u, %x, %p.            
Is user input passed to printf, scanf or similiar functions in a way you can control?    

        printf(variable);   //c code vulnerability   
        %x%x   #test as user input   
        %p %p    #print out pointer values - test to see if you can disclose vital info (like a flag)  
But what if the string contains a format parameter?? The format function should eval and try to access the function arg by adding to the frame pointer - if arg isn't there adding to the frame pointer will reference a piece of memory in a preceding stack frame.       
Further notes: https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b             
        
## GEF    
[GEF Documentation](https://hugsy.github.io/gef/)    
Extend the features of GDB.    
Check security protections on a binary:     

    checksec filename  
    checksec     #if gdb is already attached to a process    

    pattern create 200    #create a pattern   
    pattern offset waab   #get the offset 

## Memory Protections 
### Quick Overview         
NX/DEP: Non execution / data execution prevention. Usually done at the hardware level, marks a region of memory as not executable. You can use ROP techniques to bypass it or find a memory region that is RWX.        
NX: Nonexecutable Stack, Linux. Defines memory regions as instructions or data - your input gets stored as data and can't be executed. ret2libc - Linux NX bypass.       
DEP: Data Execution Prevention, Windows version of NX, the CPU will not execute code in the heap or stack.   

Stack Canary / stack cookie / stack smashing protector: adds a value in front of the instruction pointer, this value will be checked before returning. Is generated per-process, first byte is usally a null byte so you can't easily leak it.        
Work around stack canaries: if you have a relative or absolute write to memory you don't need to write the canary. You may be able to leak the canary, if you can read memory. If the return is not immediately or never called, you might be able to overwrite the null byte and leak the canary.    
/GS: Windows compiler option that enables a stack canary / security cookie, use /GS- to compile without stack checks. On by default in modern Visual Studio. XORs and compares the return address on the stack to the stack cookie seed value. If the values don't match - programs throws and exception and terminates.            

ASLR: address space layer randomization. Instead of preventing execution on the stack - randomize the stack memory layout. Attacker won't know where the waiting shellcode is to return execution into it. ASLR takes a segment which is going to exist in the new process, checks if it has a fixed address requirement - if it doesn't ASLR applies a random page offset.             
ASLR is a setting of the OS. When a program or library is loaded, ASLR will apply to every memory segment it can. The stack / heap will always be random. The randomization happens at load time - to perform an address leak it needs to be as the same program is running.            
Memory pages need to be aligned, so you know the lowest 12 bits. x86: restricted address space (PIE base only has 8/32 bits of randomization). x64 Windows: ASLR has a larger entropy (up to 19 bits) so is more effective.        
Defeating ASLR: use an info leak vulnerability (like a format string vulnerability that can leak an address), brute force an address (possible on 32 bit since the address space is limited), find a module that is compiled without ASLR.       
                
PIE - Position Independent Executables (PIE), protects against ROP attacks. The binary and it's dependancies are loaded into random locations in virtual memory each time the program is executed. The binary stores rip-relative offsets and relocations instead of any pointers. PIE generates code that finds things by offset, instead of by hardcoded memory addresses. Compile with PIC (Position Independent Code) to generate a PIE (Position Independent Executable). Once you know the base of a PIE - you know where all the functions are.       
PIE is a setting of the binary code section in the program file. It is used mostly for building shared libraries where the runtime location of the library depends on outside factors.        

SafeSEH:     

Relocation Read-Only (RELRO)       

Control Flow Guard (CFG): Windows protection, implements control flow integrity. Validates indirect code branching to prevent the overwrite of function pointers in exploits. Common bypass technique: overwrite return address on the stack using a format string vulnerability.       

PatchGuard / KPP (Kernel Patch Protection): x64 Windows memory protection that protects critical areas of the kernel, in use since Windows Vista. Protects the SSDT, GDT, IDT, system images, processor MSRs. Restricts software from making extensions to the Windows kernel. Unable to completely prevent patching - device drivers have the same privilege level as the kernel and are able to bypass and patch. Attack scenario - use a vulnerable kernel driver with a valid EV certificate to get low level execution privileges.                     

SMEP / SMAP   
[Windows SMEP Bypass](https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf) 
Kernel exploit mitigations    
SMAP: allow pages to be protected from supervisor-mode data accesses, prevents kernelmode from executing on user mode addresses. If SMAP is 1, software in supervisor mode can't access data at linear addresses that are accessible in user mode.       
SMEP: Supervisor Mode Execution Prevention. Protects pages from supervisor-mode instruction fetches. If SMEP is 1, software in supervisor mode can't fetch instructions at linear addresses that are accessible in user mode. Detects Ring - code running in user space, enabled by default since Windows 8. Relevant to local privilege escalation.               
SMEP bypass techniques: jump to code in user space, jump to the kernel heap (doesn't work on x64), use a ROP chain in kernel space to bypass, ROP to unprotecting hal.dll heap to write shellcode in that area and jump to that code, disable flags in the CR4 register to turn off SMEP / SMAP: 20th bit for SMEP. 

DSE:      

Code Integrity Guard (CIG), Arbitrary Code Guard (ACG)      
CIG  - only allows properly signed images to load. ACG: code can't be dynamically generated or modified.     


## NX   
### Linux   
Compile a binary with NX turned off:    
> gcc -fno-stack-protector -z execstack -o binary source.c      

Turn off NX system wide on older systems:    
> echo 0 > /proc/sys/kernel/exec-shield  
Turn off NX system wide on newer systems (Kali 2023) until the next reboot:    
[Walkthrough here](https://davidhamann.de/2020/09/09/disable-nx-on-linux/)    

         dmesg | grep NX     #check to see if NX is active   
         reboot and interrupt the GRUB menu 
         noexec=off noexec32=off     #add this to the end of the correct linux line  
Execstack: set, clear or query the NX bit of an ELF binary or shared library.     

        execstack -q binary   #check the status of exec stack   
        execstack -s binary   #require an executable stack   
        execstack -c binary   #accepts an unexecutable stack 
More portable version of execstack [here](https://github.com/skeeto/scratch/blob/master/parsers/execstack.c)     
### Windows    
DEP: prevents code execution from data pages by raising an exception when attempts are made. Most common DEP bypass: using some kind of ROP chain.        
Turn off DEP perprocess on modern Windows: search Exploit Protection > Program Settings > Add program to customize and deselect DEP options     
Global level: use bcdedit to change the DEP setting. Default settings: Win7/Win10 - OptIn, Win Server 2012 / 2019 - /AlwaysOn.       

## ASLR     
### Linux    
Enable / disable kernel level ASLR in GDB:    

        (gdb) set disable-randomization on
        (gdb) set disable-randomization off
        (gdb) show disable-randomization

Switch off ASLR system wide:      

        $echo 0 | sudo tee /proc/sys/kernel/randomize_va_space     
        $echo 2 | sudo tee /proc/sys/kernel/randomize_va_space      #switch full ASLR back on   
PIE - needed for ASLR to be enabled.          

        gcc -no-pie    #compile a binary without PIE    
### Windows   
Implemented in Windows Vista. ASLR randomizes the base addresses of loaded applications and DLLs every time the OS is booted. Goal of ASLR: mitigate exploits that defeat DEP with ROP.       
Windows XP: no ASLR, the base address of DLLs is always the same. Early ASLR bypasses: leveraged modules without ASLR enabled, was effective against browsers due to Java version 6 (msvcr71.dll).       
Check if ASLR is enabled.    
> dumpbin.exe /headers test.exe    #look for DynamicBase bit under DllCharacteristics field of the PE header   
Turn off ASLR on modern Windows: search Exploit Protection > Program Settings > Add program to customize and deselect ASLR       
Windows Defender Exploit Guard (WDEG): in the Win10 Creators update. Enables enforcing security mitigations like DEP and ASLR even if the developer didn't compile with them.      

Ex of bypassing DEP + ASLR - use Win32 WriteProcessMemory API. 

Brute forcing the base address of a target module - only really feasible on x86 (due to low entropy). Main limit - will only work for applications that don't crash when there's an invalid ROP address or when the application is auto restarted after a crash.      

Info leak: leverage a vulnerability to leak the address of a loaded module then exploit it using another vulnerability. Ex - leverage a format string vulnerability to leak a module address then use a stack buffer overflow to get code execution by bypassing DEP through a ROP chain. Info leak vulns are usually found through a logical vulnerability or memory corruption.        
Read primitive: leak or read semi arbitrary memory.   
Windows APIs that can be exploited to cause an info leak: DebugHelp, EnumProcessModules, CreateToolhelp32Snapshot. C runtime functions: fopen     
Format string vulnerabilities: might be able to leak an address and execute code. Ie - leak address of an exported function, then get the base address of a module using the leaked function virtual address (VA = image base + RVA). Want module with no null bytes in the uppermost byte of the base address. Get address of WriteProcessMemory - use to copy shellcode into an executable page, call using a ROP chain (base address + offset).              
WriteProcessMemory(handle_to_process, dest_address, src_address, size, num_bytes_written);    //need to place these args on the stack   
Code page: gets filled with null bytes at the end to ensure page alignment. Attacker can use this as a "code cave", look for NULL bytes at the end of a code section's upper bounds. Exploit: dynamically update the address of / size of the shellcode.              
Might need to use a ROP decoder - manually replace bad chars w/ safe chars that won't break an exploit. Custom: track where bytes are changed and how they are changed, reuse that when decoding. Get indexes of bad chars, encode the bad chars. Decoder ROP chain to handle the bad chars.          
Gadgets: get base address of the DLL dynamically, then use offset to get the gadget address and add to the chain.                    
Common stack pivot gadgets:        

  mov esp, r32       ;32 bit register with addr of buffer where ROP chain is                    
  xchg esp, r32   

Format specifier prototype:               

    %[flags][width][.precision][length]specifier     

Format string vulnerability: submitted data of an input string is evaluated as a command by the application and not properly validated. Vuln functions: fprintf, printf, sprintf, snprintf, vfprintf, vprintf, vsprintf, vsnprintf. If the number of format string specifiers is greater then the number of arguments - possible vulnerability, might be able to view addresses of data on the stack. An attacker needs to be able to change the format string or number of arguments to exploit a vulnerability like this.                
Common params used in an attack: %%, %p, %d, %c, %u, %x, %s, %n         
Might need to execute an exploit several time to verify consistency of addresses. Need to be able to receive the address on the attacker side for the vulnerability to be useful - will depend on the application, needs to be a remote stack address leak.           
If the application is multithreaded - stack addresses should change each time the exploit poC runs. To avoid stack addr changing - use same socket session to trigger the stack leak. Across multiple reruns of an exploit - pointers at higher addresses aren't stable across multiple packet transmissions. Ideally - want to use a pointer from kernel32.dll or kernelbase.dll, calc offset from leaked stack address to chosen function - this offset should be consistent.              
Write primitive: modify content in memory. Use it to overwrite the instruction pointer and execute code in memory.     
%n: writes the number of bytes written so far to an address, if compiler wasn't secure - might be able to use. Would get an access violation when you try to invoke an invalid address if %n is enabled. Might be able to get the application to write to a valid address.      

 
## Return Oriented Programming (ROP)       
[Ropper tool](https://scoding.de/ropper/)     
[ROPGadget](https://github.com/JonathanSalwan/ROPgadget)     
Allows you to bypass NX on Linux systems / DEP on Windows systems          
Common defense against ROP techniques: ASLR         
https://bordplate.no/blog/en/post/what-is-rop/    
https://bordplate.no/blog/en/post/interactive-rop-tutorial/    
[Return Oriented Shellcode](https://www.youtube.com/watch?v=7BMyVvYv5d0)    
Gadget: byte sequence in a program of instruction + ret. Chain together several gadgets to make the program do what you want. You can extract patterns from different parts of the instruction set.              
Chain together small snippets of useful assembly code in the binary (or others loaded by it) - the goal is usually to call system("/bin/sh")      
x64 Linux example: set the registers %rdi = address of string "/bin/sh" , %rsi = 0, %rdx = 0, then jump to the address of system      
CTF ex: find the location of 'cat flag.txt' and pass it to system() to execute it and return the output.          

 ropper -f vuln    #dump a list of found gadgets   

ROP: not directly prevented with NX. Can use ROP to execute a mmap / mprotect syscall and effectively remove NX.      
Useful op codes:     

        90    ; NOP (no operation) op code, increments instruction pointer by 1.      
        c3    ; ret op code   
Generate opcode yourself:    
```
; test.s with the instructions you want                                                                  
movq %rsp,%rax 
ret
```
gcc -c test.s -o test    #generate machine code with AT&T assembly   
gcc -c test.s -o test -masm=intel    #generate machine code with Intel assembly     
objdump -d test        #view the machine code and the op codes you want, then search the target binary for them 
If you are chaining together multiple gadgets - usually they should all end with "ret". On x86-64 your gadget addresses will need to be on the stack in Little Endian format (reversed in 1 byte chunks).     
### ROP on Windows    
Bypass DEP: use ROP to execute a call to VirtualAlloc to change the memory permissions of where your shellcode is located and execute it. If DEP is enabled - unable to disable it for the entire process.       
Other DEP bypass option: use Win32 WriteProcessMemory API. Hot patch the code section (.text) of a running process, inject your shellcode then jump into it. API patches memory by calling NtProtectVirtualMemory.      
Option: use a 100% ROP chain to execute code or use ROP to disable NX, then execute our shellcode.    
2nd option - allocate a chunk of memory with write and execute permissions and copy shellcode to it.   

General ROP Steps:    
- Locate executable pages.   
- Locate ret instructions in those pages, search backwards from them for possible gadgets.   
- Check that the addresses of the gadgets don't contain bad characters. Might need to avoid an upper null byte in the address.   
Locating gadgets: easier using automated tools like [rp++](https://github.com/0vercl0k/rp) or Pykd WinDbg extension.     
Figure out what memory pages are executable      
Executable page values: PAGE_EXECUTE (0x10), PAGE_EXECUTE_READ (0x20), PAGE_EXECUTE_READWRITE (0x20) PAGE_EXECUTE_WRITECOPY (0x80)        
ret on x86: pops esp into eip, esp+4, op code: c3. ret 0xXX - pops esp into eip, esp + 0xXX bytes, op code: c2  offset. Search for c3 / c2 to find return instructions.        
Avoid privileged instructions that cause an access violation or instructions with jmp / calls (avoid longer gadgets). Each gadget should end with a ret.       
Using ROP w/ VirtualAlloc to bypass DEP: use a call to VirtualAlloc to change the state of pages in the virtual address space of the calling process. Need to place a skeleton of the function call onto the stack, modify the address and parameters using ROP, and then ret into it. Dynamically getting the address of VirtualAlloc- Can use the IAT entry w/ the memory dereference to fetch the addr of VirtualAlloc at runtime as part of the ROP chain.      
Call to VirtualAlloc should have the arguments:   
VirtualAlloc(shellcode_addr, 0x01, 0x1000, 0x40);   //address, size, allocation type, protect flag. Can supply dummy args then patch them at runtime using ROP     
Can avoid NULL bytes using negation. Also can leverage that overflow bits on a 32 bit system will be discarded.     

### ret2libc (Return to libc)     
[Return to Libc Explained](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)    
[Bypassing non-executable-stack during exploitation using return-to-libc](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)    
Exploit buffer overflows on systems where stack memory is protected with NX. For *nix systems.        
An attacker can't execute shellcode from the stack. ret2libc: bypass NX and use existing code from the standard C library shared object (/lib/i386-linux-gnu/libc-\*.so) that is loaded and mapped into the program's virtual address space. This is similiar to a standard stack buffer overflow, except the return address will point to the function system(const char *command) from the libc library. The program will be forced to jump to system() and execute injected shellcode as the command.                
payload = overflow + &system() + &exit() + &commmand       

        (gdb) p system  #find the memory address of system() from libc in the program's virtual memory    
        (gdb) p exit    #find the memory address of exit() 

### Sigreturn-oriented programming (SROP)     
[Linux Syscall Table](https://filippo.io/linux-syscall-table/)    
If we can only control the eax/rax register. 
Ex - Make a syscall used to restore the entire register context from memory pointed at by ESP. Use mmap (create new memory) or mprotect (change memory permissions) to create a WRX region of memory for shellcoding (if needed).  Use a sigreturn syscall to set all registers.         

## Structured Exception Handlers (SEH)    
[Fuzzy Security SEH Tutorial](https://fuzzysecurity.com/tutorials/expDev/3.html)   
Used to bypass stack cookies and SafeSEH.   
SEH overwrite: stack based buffer overflow overwrites an exception registration stored on a thread's state. Usually: "POP R32, POP R32, RET". Attacker can sometimes force an exception by increasing the size of the overflow. Generally the last exception record struct is overwritten first, might be able to overwrite more then 1/              
SEHOP: prevents SEH overwrites by checking the SEH chain. Dynamic checks to the exception dispatcher that don't need metadata from a binary. Verifies a thread's exception handler list is intact before handlers can be called. On Windows Server 2008+.              
/SAFESEH compiler option. Linker produces an image with a table of safe exception handlers, exception handler to be called will be comapred against this table. Bypass SAFESEH on x86: leverage POP R32, POPR32, RET in a loaded module without memory protections.                

## RELocation Read-Only    
https://blog.osiris.cyber.nyu.edu/exploitation%20mitigation%20techniques/exploitation%20techniques/2011/06/02/relro-relocation-read-only/     
ELF relocation sections      

## PatchGuard / KPP      
[Bypassing PatchGuard at runtime](https://hexderef.com/patchguard-bypass)     