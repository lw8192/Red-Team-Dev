# Binary Exploitation    
## Learn     
[Flagbot CTF Lessons](https://flagbot.ch/material/)     
[Live Overflow Paylist](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)   
[Binary Exploitation Notes](https://ir0nstone.gitbook.io/notes/)       
[Binary Exploitation Roadmap](https://www.hoppersroppers.org/roadmap/training/pwning.html)       
 
## Tools     
[GDB](https://www.sourceware.org/gdb/)    
[GEF](https://github.com/hugsy/gef)   
[Cutter](https://cutter.re/)    
[PEDA](https://github.com/longld/peda)    
[Pwntools](https://github.com/Gallopsled/pwntools), [Pwntools Tutorials](https://github.com/Gallopsled/pwntools-tutorial)        
Ghidra    
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly2)    
32 vs 64 bit: the main difference is how you pass arguments to functions. In 32 bit systems, arguments are pushed to the stack before a function is called. In 64 bit the first 6 arguments are pushed to RDI, RSI, RDX, RCX, R8 and R9. Some OSs might have different calling coventions.         


        file binary     #note architechure of the binary, are debugging symbols stripped?     
        strings binary   #note strings, function calls   

If a binary is not stripped of debugging symbols:    

        readelf -s program     
Disassemble and find function locations:       

        objdump -d program     
Open the binary in Ghidra, decompile it and look at the source code.   
ltrace: record library calls made in an executable to see what context they are used in.      

        ltrace ./program      

## Format String Vulnerabilities     
Format parameter: Escape sequences - begins with a %, uses a single char shorthand. Common format parameters: %d, %u, %x, %p.            
Is user input passed to printf, scanf or similiar functions in a way you can control?    

        printf(variable);   //c code vulnerability   
        %x%x   #test as user input   
        %p %p    #print out pointer values - test to see if you can disclose vital info (like a flag)  
But what if the string contains a format parameter?? The format function should eval and try to access the function arg by adding to the frame pointer - if arg isn't there adding to the frame pointer will reference a piece of memory in a preceding stack frame.       
Further notes: https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b             
        
## GEF    
[GEF Documentation](https://hugsy.github.io/gef/)    
Extend the features of GDB.    
Check security protections on a binary:     

    checksec filename  
    checksec     #if gdb is already attached to a process    

    pattern create 200    #create a pattern   
    pattern offset waab   #get the offset 

## Memory Protections      
Non execution / data execution prevention: usually done at the hadrware level, marks a region of memory as not executable. You can use ROP techniques to bypass it or find a memory region that is RWX.        
NX: Nonexecutable Stack, Linux. Defines memory regions as instructions or data - your input gets stored as data and can't be executed. ret2libc - NX bypass.       
DEP: Data Execution Prevention, Windows version of NX, the CPU will not execute code in the heap or stack.   

Stack Canary / stack cookie / stack smashing protector: adds a value in front of the instruction pointer, this value will be checked before returning. Is generated per-process, nfirst byte is usally a null byte so you can't easily leak it.        
Work around stack canaries: if you have a relative or absolute write to memory you don't need to write the canary. You may be able to leak the canary, if you can read memory. If the return is not immediately or never called, you might be able to voerwrite the null byte and leak the canary. 

ASLR:  address space layer randomization. Instead of preventing execution on the stack - randomize the stack memory layout. Attacker won't know where the waiting shellcode is to return execution into it. ASLR takes a segment which is going to exist in the new process, checks if it has a fixed address requirement - if it doesn't ASLR applies a random page offset.             
ASLR is a setting of the OS. When a program or library is loaded, ASLR will apply to every memory segment it can. The stack / heap will always be random. The randomization happens at load time - to perform an address leak it needs to be as the same program is running.            
Memory pages need to be aligned, so you know the lowest 12 bits. x86: restricted address space (PIE base only has 8 bits of randomization).    
                
PIE - Position Independent Executables (PIE), protects against ROP attacks. The binary and it's dependancies are loaded into random locations in virtual memory each time the program is executed. The binary stores rip-relative offsets and relocations instead of any pointers. PIE generates code that finds things by offset, instead of by hardcoded memory addresses. Compile with PIC (Position Independent Code) to generate a PIE (Position Independent Executable). Once you know the base of a PIE - you know where all the functions are.       
PIE is a setting of the binary code section in the program file.    

SafeSEh:     

Relocation Read-Only (RELRO)       

## NX   
### Linux   
Compile a binary with NX turned off:    

  gcc -fno-stack-protector -z execstack -o binary source.c      

Turn off NX system wide on older systems:    

        echo 0 > /proc/sys/kernel/exec-shield  
Turn off NX system wide on newer systems (Kali 2023) until the next reboot:    
[Walkthrough here](https://davidhamann.de/2020/09/09/disable-nx-on-linux/)    

         dmesg | grep NX     #check to see if NX is active   
         reboot and interrupt the GRUB menu 
         noexec=off noexec32=off     #add this to the end of the correct linux line  
Execstack: set, clear or query the NX bit of an ELF binary or shared library.     

        execstack -s binary      #enable an executable stack on a program   
If you have trouuble installing execstack you can install a more portable version [here](https://github.com/skeeto/scratch/blob/master/parsers/execstack.c)     

        execstack -q binary   #check the status of exec stack   
        execstack -s binary   #require an executable stack   
        execstack -c binary   #accepts an unexecutable stack 

## ASLR     
### Linux    
Enable / disable kernel level ASLR in GDB:    

        set disable-randomization on
        set disable-randomization off
        show disable-randomization

Switch off ASLR system wide:      

        $echo 0 | sudo tee /proc/sys/kernel/randomize_va_space     
        $echo 2 | sudo tee /proc/sys/kernel/randomize_va_space      #switch ASLR back on

## Return Oriented Programming (ROP)       
[Ropper tool](https://scoding.de/ropper/)     
[ROPGadget](https://github.com/JonathanSalwan/ROPgadget)     
Allows you to bypass NX on Linux systems, avoid DEP on Windows systems          
Common defense against ROP techniques: ASLR         
https://bordplate.no/blog/en/post/what-is-rop/    
https://bordplate.no/blog/en/post/interactive-rop-tutorial/    
[Return Oriented Shellcode](https://www.youtube.com/watch?v=7BMyVvYv5d0)    
Gadget: byte sequence in a program of instruction + ret. Chain together several gadgets to make the program do what you want. You can extract patterns from different parts of the instruction set.              
Chain together small snippets of useful assembly code in the binary (or others loaded by it) - the goal is usually to call system("/bin/sh")      
x64 Linux example: set the registers %rdi = address of string "/bin/sh" , %rsi = 0, %rdx = 0, then jump to the address of system      
CTF ex: find the location of 'cat flag.txt' and pass it to system() to execute it and return the output.          

 ropper -f vuln    #dump a list of found gadgets   

ROP: not directly prevented with NX. Can use ROP to execute a mmap / mprotect syscall and effectively remove NX.      
Useful op codes:     

        c3    ; ret op code   
### ret2libc (Return to libc)     
[Return to Libc Explained](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)    
[Bypassing non-executable-stack during exploitation using return-to-libc](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)    
Exploit buffer overflows on systems where stack memory is protected with NX. For *nix systems.        
An attacker can't execute shellcode from the stack. ret2libc: bypass NX and use existing code from the standard C library shared object (/lib/i386-linux-gnu/libc-\*.so) that is loaded and mapped into the program's virtual address space. This is similiar to a standard stack buffer overflow, except the return address will point to the function system(const char *command) from the libc library. The program will be forced to jump to system() and execute injected shellcode as the command.                
payload = overflow + &system() + &exit() + &commmand       

        (gdb) p system  #find the memory address of system() from libc in the program's virtual memory    
        (gdb) p exit    #find the memory address of exit() 

### Sigreturn-oriented programming (SROP)     
[Linux Syscall Table](https://filippo.io/linux-syscall-table/)    
If we can only control the eax/rax register. 
Ex - Make a syscall used to restore the entire register context from memory pointed at by ESP. Use mmap (create new memory) or mprotect (change memory permissions) to create a WRX region of memory for shellcoding (if needed).  Use a sigreturn syscall to set all registers.         

## Structured Exception Handlers (SEH)    
[Fuzzy Security SEH Tutorial](https://fuzzysecurity.com/tutorials/expDev/3.html)   
Used to bypass stack cookies and SafeSEH.   
