# Binary Exploitation    
## Learn     
[Flagbot CTF Lessons](https://flagbot.ch/material/)     
[Live Overflow Paylist](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)   
[Binary Exploitation Notes](https://ir0nstone.gitbook.io/notes/)       
[Binary Exploitation Roadmap](https://www.hoppersroppers.org/roadmap/training/pwning.html)       
 
## Tools     
[GDB](https://www.sourceware.org/gdb/)    
[GEF](https://github.com/hugsy/gef)   
[Cutter](https://cutter.re/)    
[PEDA](https://github.com/longld/peda)    
[Pwntools](https://github.com/Gallopsled/pwntools), [Pwntools Tutorials](https://github.com/Gallopsled/pwntools-tutorial)        
Ghidra    
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly2)    
32 vs 64 bit: the main difference is how you pass arguments to functions. In 32 bit systems, arguments are pushed to the stack before a function is called. In 64 bit the first 6 arguments are pushed to RDI, RSI, RDX, RCX, R8 and R9. Some OSs might have different calling coventions.         


        file binary     #note architechure of the binary, are debugging symbols stripped?     
        strings binary   #note strings, function calls   

If a binary is not stripped of debugging symbols:    

        readelf -s program     
Disassemble and find function locations:       

        objdump -d program     
Open the binary in Ghidra, decompile it and look at the source code.   
ltrace: record library calls made in an executable to see what context they are used in.      

        ltrace ./program      

## Format String Vulnerabilities     
Format parameter: Escape sequences - begins with a %, uses a single char shorthand. Common format parameters: %d, %u, %x, %p.            
Is user input passed to printf, scanf or similiar functions in a way you can control?    

        printf(variable);   //c code vulnerability   
        %x%x   #test as user input   
        %p %p    #print out pointer values - test to see if you can disclose vital info (like a flag)  
But what if the string contains a format parameter?? The format function should eval and try to access the function arg by adding to the frame pointer - if arg isn't there adding to the frame pointer will reference a piece of memory in a preceding stack frame.       
Further notes: https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b             
        
## GEF    
[GEF Documentation](https://hugsy.github.io/gef/)    
Extend the features of GDB.    
Check security protections on a binary:     

    checksec filename  
    checksec     #if gdb is already attached to a process    

    pattern create 200    #create a pattern   
    pattern offset waab   #get the offset 

## Memory Protections 
### Quick Overview         
NX/DEP: Non execution / data execution prevention. Usually done at the hardware level, marks a region of memory as not executable. You can use ROP techniques to bypass it or find a memory region that is RWX.        
NX: Nonexecutable Stack, Linux. Defines memory regions as instructions or data - your input gets stored as data and can't be executed. ret2libc - Linux NX bypass.       
DEP: Data Execution Prevention, Windows version of NX, the CPU will not execute code in the heap or stack.   

Stack Canary / stack cookie / stack smashing protector: adds a value in front of the instruction pointer, this value will be checked before returning. Is generated per-process, first byte is usally a null byte so you can't easily leak it.        
Work around stack canaries: if you have a relative or absolute write to memory you don't need to write the canary. You may be able to leak the canary, if you can read memory. If the return is not immediately or never called, you might be able to overwrite the null byte and leak the canary.    
/GS: Windows compiler option that enables a stack canary / security cookie, use /GS- to compile without stack checks. On by default in modern Visual Studio. XORs and compares the return address on the stack to the stack cookie seed value. If the values don't match - programs throws and exception and terminates.            

ASLR: address space layer randomization. Instead of preventing execution on the stack - randomize the stack memory layout. Attacker won't know where the waiting shellcode is to return execution into it. ASLR takes a segment which is going to exist in the new process, checks if it has a fixed address requirement - if it doesn't ASLR applies a random page offset.             
ASLR is a setting of the OS. When a program or library is loaded, ASLR will apply to every memory segment it can. The stack / heap will always be random. The randomization happens at load time - to perform an address leak it needs to be as the same program is running.            
Memory pages need to be aligned, so you know the lowest 12 bits. x86: restricted address space (PIE base only has 8 bits of randomization).    
Defeating ASLR: info leak vulnerability (like a format string vulnerability that can leak an address), brute force an address (possible on 32 bit since the address space is limited), find a module that is compiled without ASLR.       
                
PIE - Position Independent Executables (PIE), protects against ROP attacks. The binary and it's dependancies are loaded into random locations in virtual memory each time the program is executed. The binary stores rip-relative offsets and relocations instead of any pointers. PIE generates code that finds things by offset, instead of by hardcoded memory addresses. Compile with PIC (Position Independent Code) to generate a PIE (Position Independent Executable). Once you know the base of a PIE - you know where all the functions are.       
PIE is a setting of the binary code section in the program file. It is used mostly for building shared libraries where the runtime location of the library depends on outside factors.        

SafeSEh:     

Relocation Read-Only (RELRO)       

Control Flow Guard (CFG): Windows protection, implements control flow integrity. Validates indirect code branching to prevent the overwrite of function pointers in exploits.   

PatchGuard / KPP (Kernel Patch Protection): x64 Windows memory protection that protects critical areas of the kernel, in use since Windows Vista. Protects the SSDT, GDT, IDT, system images, processor MSRs. Restricts software from making extensions to the Windows kernel. Unable to completely prevent patching - device drivers have the same privilege level as the kernel and are able to bypass and patch. Attack scenario - use a vulnerable kernel driver with a valid EV certificate to get low level execution privileges.                     

SMEP / SMAP   
[Windows SMEP Bypass](https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf) 
Kernel exploit mitigations    
SMAP: allow pages to be protected from supervisor-mode data accesses, prevents kernelmode from executing on user mode addresses. If SMAP is 1, software in supervisor mode can't access data at linear addresses that are accessible in user mode.       
SMEP: Supervisor Mode Execution Prevention. Protects pages from supervisor-mode instruction fetches. If SMEP is 1, software in supervisor mode can't fetch instructions at linear addresses that are accessible in user mode. Detects Ring - code running in user space, enabled by default since Windows 8. Relevant to local privilege escalation.               
SMEP bypass techniques: jump to code in user space, jump to the kernel heap (doesn't work on x64), use a ROP chain in kernel space to bypass, ROP to unprotecting hal.dll heap to write shellcode in that area and jump to that code, disable flags in the CR4 register to turn off SMEP / SMAP: 20th bit for SMEP. 

DSE:      

Code Integrity Guard (CIG), Arbitrary Code Guard (ACG)      
CIG  - only allows properly signed images to load. ACG: code can't be dynamically generated or modified.     


## NX   
### Linux   
Compile a binary with NX turned off:    
> gcc -fno-stack-protector -z execstack -o binary source.c      

Turn off NX system wide on older systems:    
> echo 0 > /proc/sys/kernel/exec-shield  
Turn off NX system wide on newer systems (Kali 2023) until the next reboot:    
[Walkthrough here](https://davidhamann.de/2020/09/09/disable-nx-on-linux/)    

         dmesg | grep NX     #check to see if NX is active   
         reboot and interrupt the GRUB menu 
         noexec=off noexec32=off     #add this to the end of the correct linux line  
Execstack: set, clear or query the NX bit of an ELF binary or shared library.     

        execstack -q binary   #check the status of exec stack   
        execstack -s binary   #require an executable stack   
        execstack -c binary   #accepts an unexecutable stack 
More portable version of exactstack [here](https://github.com/skeeto/scratch/blob/master/parsers/execstack.c)     
### Windows    
DEP: prevents code execution from data pages by raising an exception when attempts are made.     
Turn off DEP on modern Windows: search Exploit Protection > Program Settings > Add program to customize and deselect DEP options     
Bypass DEP: use ROP to execute a call to VirtualAlloc to change the memory permissions of where your shellcode is located and execute it.   

## ASLR     
### Linux    
Enable / disable kernel level ASLR in GDB:    

        (gdb) set disable-randomization on
        (gdb) set disable-randomization off
        (gdb) show disable-randomization

Switch off ASLR system wide:      

        $echo 0 | sudo tee /proc/sys/kernel/randomize_va_space     
        $echo 2 | sudo tee /proc/sys/kernel/randomize_va_space      #switch full ASLR back on   
PIE - needed for ASLR to be enabled.          

        gcc -no-pie    #compile a binary without PIE    
### Windows   
Implemented in Windows Vista. ASLR randomizes the base addresses of loaded applications and DLLs every time the OS is booted.   
Windows XP: no ASLR, the base address of DLLs is always the same.    
Check if ASLR is enabled.    
> dumpbin.exe /headers test.exe    #look for Dynamic Base under Dll Characteristics 
Turn off ASLR on modern Windows: search Exploit Protection > Program Settings > Add program to customize and deselect ASLR       

## Return Oriented Programming (ROP)       
[Ropper tool](https://scoding.de/ropper/)     
[ROPGadget](https://github.com/JonathanSalwan/ROPgadget)     
Allows you to bypass NX on Linux systems / DEP on Windows systems          
Common defense against ROP techniques: ASLR         
https://bordplate.no/blog/en/post/what-is-rop/    
https://bordplate.no/blog/en/post/interactive-rop-tutorial/    
[Return Oriented Shellcode](https://www.youtube.com/watch?v=7BMyVvYv5d0)    
Gadget: byte sequence in a program of instruction + ret. Chain together several gadgets to make the program do what you want. You can extract patterns from different parts of the instruction set.              
Chain together small snippets of useful assembly code in the binary (or others loaded by it) - the goal is usually to call system("/bin/sh")      
x64 Linux example: set the registers %rdi = address of string "/bin/sh" , %rsi = 0, %rdx = 0, then jump to the address of system      
CTF ex: find the location of 'cat flag.txt' and pass it to system() to execute it and return the output.          

 ropper -f vuln    #dump a list of found gadgets   

ROP: not directly prevented with NX. Can use ROP to execute a mmap / mprotect syscall and effectively remove NX.      
Useful op codes:     

        90    ; NOP (no operation) op code, increments instruction pointer by 1.      
        c3    ; ret op code   
Generate opcode yourself:    
```
; test.s with the instructions you want                                                                  
movq %rsp,%rax 
ret
```
gcc -c test.s -o test    #generate machine code with AT&T assembly   
gcc -c test.s -o test -masm=intel    #generate machine code with Intel assembly     
objdump -d test        #view the machine code and the op codes you want, then search the target binary for them 
If you are chaining together multiple gadgets - usually they should all end with "ret". On x86-64 your gadget addresses will need to be on the stack in Little Endian format (reversed in 1 byte chunks).     

### ret2libc (Return to libc)     
[Return to Libc Explained](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)    
[Bypassing non-executable-stack during exploitation using return-to-libc](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)    
Exploit buffer overflows on systems where stack memory is protected with NX. For *nix systems.        
An attacker can't execute shellcode from the stack. ret2libc: bypass NX and use existing code from the standard C library shared object (/lib/i386-linux-gnu/libc-\*.so) that is loaded and mapped into the program's virtual address space. This is similiar to a standard stack buffer overflow, except the return address will point to the function system(const char *command) from the libc library. The program will be forced to jump to system() and execute injected shellcode as the command.                
payload = overflow + &system() + &exit() + &commmand       

        (gdb) p system  #find the memory address of system() from libc in the program's virtual memory    
        (gdb) p exit    #find the memory address of exit() 

### Sigreturn-oriented programming (SROP)     
[Linux Syscall Table](https://filippo.io/linux-syscall-table/)    
If we can only control the eax/rax register. 
Ex - Make a syscall used to restore the entire register context from memory pointed at by ESP. Use mmap (create new memory) or mprotect (change memory permissions) to create a WRX region of memory for shellcoding (if needed).  Use a sigreturn syscall to set all registers.         

## Structured Exception Handlers (SEH)    
[Fuzzy Security SEH Tutorial](https://fuzzysecurity.com/tutorials/expDev/3.html)   
Used to bypass stack cookies and SafeSEH.   
SEH overwrite: stack based buffer overflow overwrites an exception registration stored on a thread's state. Usually: "POP R32, POP R32, RET". Attacker can sometimes force an exception by increasing the size of the overflow. Generally the last exception record struct is overwritten first, might be able to overwrite more then 1/              
SEHOP: prevents SEH overwrites by checking the SEH chain. Dynamic checks to the exception dispatcher that don't need metadata from a binary. Verifies a thread's exception handler list is intact before handlers can be called. On Windows Server 2008+.              
/SAFESEH compiler option. Linker produces an image with a table of safe exception handlers, exception handler to be called will be comapred against this table. Bypass SAFESEH on x86: leverage POP R32, POPR32, RET in a loaded module without memory protections.                

## RELocation Read-Only    
https://blog.osiris.cyber.nyu.edu/exploitation%20mitigation%20techniques/exploitation%20techniques/2011/06/02/relro-relocation-read-only/     
ELF relocation sections      

## PatchGuard / KPP      
[Bypassing PatchGuard at runtime](https://hexderef.com/patchguard-bypass)     