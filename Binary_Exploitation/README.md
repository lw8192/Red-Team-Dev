# Binary Exploitation    
## Learn     
[Flagbot CTF Lessons](https://flagbot.ch/material/)     
[Live Overflow Paylist](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)   
[Binary Exploitation Notes](https://ir0nstone.gitbook.io/notes/)       
[Binary Exploitation Roadmap](https://www.hoppersroppers.org/roadmap/training/pwning.html)       
 
## Tools     
[GDB](https://www.sourceware.org/gdb/)    
[GEF](https://github.com/hugsy/gef)   
[Cutter](https://cutter.re/)    
[PEDA](https://github.com/longld/peda)    
[Pwntools](https://github.com/Gallopsled/pwntools), [Pwntools Tutorials](https://github.com/Gallopsled/pwntools-tutorial)        
Ghidra    
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly2)    
32 vs 64 bit: the main difference is how you pass arguments to functions. In 32 bit systems, arguments are pushed to the stack before a function is called. In 64 bit the first 6 arguments are pushed to RDI, RSI, RDX, RCX, R8 and R9. Some OSs might have different calling coventions.         


        file binary     #note architechure of the binary, are debugging symbols stripped?     
        strings binary   #note strings, function calls   

If a binary is not stripped of debugging symbols:    

        readelf -s program     
Disassemble and find function locations:       

        objdump -d program     
Open the binary in Ghidra, decompile it and look at the source code.   
ltrace: record library calls made in an executable to see what context they are used in.      

        ltrace ./program      

## Format String Vulnerabilities     
Format parameter: Escape sequences - begins with a %, uses a single char shorthand. Common format parameters: %d, %u, %x, %p.            
Is user input passed to printf, scanf or similiar functions in a way you can control?    

        printf(variable);   //c code vulnerability   
        %x%x   #test as user input   
        %p %p    #print out pointer values - test to see if you can disclose vital info (like a flag)  
But what if the string contains a format parameter?? The format function should eval and try to access the function arg by adding to the frame pointer - if arg isn't there adding to the frame pointer will reference a piece of memory in a preceding stack frame.       
Further notes: https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b             
        
## GEF    
[GEF Documentation](https://hugsy.github.io/gef/)    
Extend the features of GDB.    
Check security protections on a binary:     

    checksec filename  
    checksec     #if gdb is already attached to a process    

    pattern create 200    #create a pattern   
    pattern offset waab   #get the offset 

## Memory Protections      
Non execution / data execution prevention: usually done at the hadrware level, marks a region of memory as not executable. You can use ROP techniques to bypass it or find a memory region that is RWX.        
NX: Nonexecutable Stack, Linux. Defines memory regions as instructions or data - your input gets stored as data and can't be executed. ret2libc - NX bypass.             
DEP: Data Execution Prevention, Windows version of NX, the CPU will not execute code in the heap or stack.   

Stack Canary / stack cookie / stack smashing protector: adds a value in front of the instruction pointer, this value will be checked before returning. Is generated per-process, nfirst byte is usally a null byte so you can't easily leak it.        
Work around stack canaries: if you have a relative or absolute write to memory you don't need to write the canary. You may be able to leak the canary, if you can read memory. If the return is not immediately or never called, you might be able to voerwrite the null byte and leak the canary. 

ASLR:  address space layer randomization. Instead of preventing execution on the stack - randomize the stack memory layout. Attacker won't know where the waiting shellcode is to return execution into it. ASLR takes a segment which is going to exist in the new process, checks if it has a fixed address requirement - if it doesn't ASLR applies a random page offset.             
ASLR is a setting of the OS. When a program or library is loaded, ASLR will apply to every memory segment it can. The stack / heap will always be random. The randomization happens at load time - to perform an address leak it needs to be as the same program is running.            
Memory pages need to be aligned, so you know the lowest 12 bits. x86: restricted address space (PIE base only has 8 bits of randomization).    
Switch off ASLR:      

                echo 0 > /proc/sys/kernel/randomize_va_space    
                
PIE - Position Independent Executables (PIE), protects against ROP attacks. The binary and it's dependancies are loaded into random locations in virtual memory each time the program is executed. The binary stores rip-relative offsets and relocations instead of any pointers. PIE generates code that finds things by offset, instead of by hardcoded memory addresses. Compile with PIC (Position Independent Code) to generate a PIE (Position Independent Executable). Once you know the base of a PIE - you know where all the functions are.       
PIE is a setting of the binary code section in the program file.    

SafeSEh:     

Relocation Read-Only (RELRO)      

## Structured Exception Handlers (SEH)    
Used to bypass stack cookies and SafeSEH.       

## Return Oriented Programming (ROP)       
[Ropper tool](https://scoding.de/ropper/)     
[ROPGadget](https://github.com/JonathanSalwan/ROPgadget)     
Allows you to bypass NX on Linux systems, avoid DEP on Windows systems          
Common defense against ROP techniques: ASLR         
https://bordplate.no/blog/en/post/what-is-rop/    
https://bordplate.no/blog/en/post/interactive-rop-tutorial/    
[Return Oriented Shellcode](https://www.youtube.com/watch?v=7BMyVvYv5d0)    
Chain together small snippets of useful assembly code in the binary (or others loaded by it) - the goal is usually to call system("/bin/sh")      
x64 Linux example: set the registers %rdi = address of string "/bin/sh" , %rsi = 0, %rdx = 0, then jump to the address of system      
CTF ex: find the location of 'cat flag.txt' and pass it to system() to execute it and return the output.          

 ropper -f vuln    #dump a list of found gadgets   

ROP: not directly prevented with NX. Can use ROP to execute a mmap / mprotect syscall and effectively remove NX.  
### ret2libc (Return to libc)     
[Return to Libc Explained](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)    
[Bypassing non-executable-stack during exploitation using return-to-libc](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)    
Exploit buffer overflows on systems where stack memory is protected with NX. For *nix systems.        
An attacker can't execute shellcode from the stack. ret2libc: bypass NX and use existing code from the standard C library shared object (/lib/i386-linux-gnu/libc-\*.so) that is loaded and mapped into the program's virtual address space. This is similiar to a standard stack buffer overflow, except the return address will point to the function system(const char *command) from the libc library. The program will be forced to jump to system() and execute injected shellcode as the command.                
payload = overflow + &system() + &exit() + &commmand       

        (gdb) p system  #find the memory address of system() from libc in the program's virtual memory    
        (gdb) p exit    #find the memory address of exit() 

### Sigreturn-oriented programming (SROP)     
[Linux Syscall Table](https://filippo.io/linux-syscall-table/)    
If we can only control the eax/rax register. 
Ex - Make a syscall used to restore the entire register context from memory pointed at by ESP. Use mmap (create new memory) or mprotect (change memory permissions) to create a WRX region of memory for shellcoding (if needed).  Use a sigreturn syscall to set all registers.         


